---
title: "NOIP 2016 D1T3: 换教室 —— 数学期望 + 动态规划"
categories:
  - OI-Solution
excerpt: "牛牛真牛。"
tags:
  - c++
  - 算法
  - 动态规划
  - 数学期望
  - NOIP
last_modified_at: 2017-03-09T14:10:02-05:00
---

* TOC
{:toc}

[题目链接](https://vijos.org/p/2005)

## 题目描述:

对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。<br>
在可以选择的课程中，有 $2n$ 节课程安排在 $n$ 个时间段上。在第 $i$ ( $1 \leq i \leq n$ )个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 $c_i$ 上课，而另一节课程在教室 $d_i$ 进行。<br>
在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 $n$ 节安排好的课程。如果学生想更换第 $i$ 节课程的教室，则需要提出申请。若申请通过，学生就可以在第 $i$ 个时间段去教室 $d_i$ 上课，否则仍然在教室 $c_i$ 上课。<br>
由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 $i$ 节课程的教室时，申请被通过的概率是一个已知的实数 $k_i$ ，并且对于不同课程的申请，被通过的概率是互相独立的。<br>
学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 $m$ 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请自己最希望更换教室的 $m$ 门课程，也可以**不用完**这 $m$ 个申请的机会，甚至可以一门课程都不申请。<br>
因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。<br>
牛牛所在的大学有 $v$ 个教室，有 $e$ 条道路。每条道路连接两间教室，并且是可以**双向通行**的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 $i$ ( $1 \leq i \leq n-1$ )节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的**路径**前往下一节课的教室。<br>
现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的**期望值**最小，请你帮他求出这个最小值。

## 输入格式:

第一行四个整数 $n$ , $m$ , $v$ , $e$ 。$n$ 表示这个学期内的时间段的数量；$m$ 表示牛牛最多可以申请更换多少节课程的教室；$v$ 表示牛牛学校里教室的数量；$e$ 表示牛牛的学校里道路的数量。<br>
第二行 $n$ 个正整数，第 $i$ ( $1 \leq i \leq n$ )个正整数表示 $c_i$ ，即第 $i$ 个时间段牛牛被安排上课的教室；保证 $1 \leq c_i \leq v$ 。<br>
第三行 $n$ 个正整数，第 $i$ ( $1 \leq i \leq n$ )个正整数表示 $d_i$ ，即第 $i$ 个时间段另一间上同样课程的教室；保证 $1 \leq d_i \leq v$。<br>
第四行 $n$ 个实数，第 $i$ ( $1 \leq i \leq n$ )个实数表示 $k_i$ ，即牛牛申请在第 $i$ 个时间段更换教室获得通过的概率。保证 $0 \leq k_i \leq 1$ 。<br>
接下来 $e$ 行，每行三个正整数 $a_j$，$b_j$，$w_j$，表示有一条双向道路连接教室 $a_j$，$b_j$，通过这条道路需要耗费的体力值是 $w_j$；保证 $1 \leq a_j, b_j \leq v$, $1 \leq w_j \leq 100$ 。<br>
保证 $1 \leq n \leq 2000$，$0 \leq m \leq 2000$， $1 \leq v \leq 300$， $0 \leq e \leq 90000$ 。
保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。<br>
保证输入的实数最多包含 $3$ 位小数。

## 输出格式:

输出一行，包含一个实数，四舍五入精确到小数点后**恰好 $2$ 位** ，表示答案。你的输出必须和标准输出**完全一样**才算正确。<br>
测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于 $4 \times 10^{-3}$ 。（如果你不知道什么是浮点误差，这段话可以理解为：对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理）

## 测试样例:

|Input|
| ---------- |
| 3 2 2 3 <br> 2 1 2 <br> 1 2 1 <br> 0.8 0.2 0.5 <br> 1 2 5 <br> 1 3 3 <br> 2 3 1|

|Output|
| ---------- |
|2.80|

## 分析:

去年在考场上做这道题的时候，我还是个刚接触 OI 一两个月、只学会了 C++ 语法和简单 dfs 的小白。所以看到这道题，什么「数学期望」，根本看都看不懂。转眼过了一年了，今年的 NOIP 又要来了。赶紧翻出前几年的题做一做，才又开始看这道题。

对于这道题呢，思考一下，好多数学期望的题都是用动态规划来做的，所以这道题我们也考虑动态规划 。<br>
首先我们要预处理出所有每两个教室之间的最短路。这道题教室的数量最多只有 300 ，所以我们完全可以用 Floyd 算法来计算最短路。<br>
我们设 $dp_{i, j, 0}$ 代表第 $i$ 个时间段不申请第 $j$ 个教室的消耗体力的期望最小值， $dp_{i, j, 1}$ 代表要申请的最小值。

考虑 $dp_{i, j, 0}$ 的转移方式。由于在第 $i$ 时间段不申请第 $j$ 个教室，所以 $dp_{i, j, 0}$ 只与它前一个时间段有没有成功申请教室有关。所以有两种情况。 $dp_{i, j, 0}$ 的转移方程长这样：

```c++
dp[i][j][0] = min(dp[i - 1][j][0] + mp[c[i - 1]][c[i]], dp[i - 1][j][1] + k[i - 1] * mp[d[i - 1]][c[i]] + (1 - k[i - 1]) * mp[c[i - 1]][c[i]]);
```
接下来考虑 $dp_{i, j, 1}$ 的转移方式。由于在第 $i$ 个时间段要申请教室了，所以它不仅与它前一次有没有成功申请有关，也与它这一次有没有成功申请有关。所以一共有四种情况。这个转移方程稍微长了一点点：

```c++
dp[i][j][1] = min(dp[i - 1][j - 1][0] + k[i] * mp[c[i - 1]][d[i]] + (1 - k[i]) * mp[c[i - 1]][c[i]], dp[i - 1][j - 1][1] + k[i - 1] * k[i] * mp[d[i - 1]][d[i]] + (1 - k[i - 1]) * k[i] * mp[c[i - 1]][d[i]] + k[i - 1] * (1 - k[i]) * mp[d[i - 1]][c[i]] + (1 - k[i - 1]) * (1 - k[i]) * mp[c[i - 1]][c[i]]);
```

最后扫一遍 $dp_{n, 1, 0}$ 到 $dp_{n, m, 0}$ ，最小值就是答案了。

## 代码:

```c++
#include <bits/stdc++.h>
using namespace std;

template<class _T> inline void read(_T &_x) {
  int _t, _flag = 0;
  while ((_t = getchar()) != '-' && (_t < '0' || _t > '9'));
  if (_t == '-')  _t = getchar(), _flag = 1;
  _x = _t - '0';
  while ((_t = getchar()) >= '0' && _t <= '9')
    _x = _x * 10 + _t - '0';
  if (_flag)  _x = -_x;
}

typedef long long ll;
typedef pair<int, int> pii;

const int MAX_N = 2000 + 100, MAX_M = 2000 + 100, MAX_V = 300 + 10, MAX_E = 90000 + 100;
const int INF = 0x3f3f3f3f;
int n, m, v, e;
int c[MAX_N], d[MAX_N];
double mp[MAX_V][MAX_V], k[MAX_N], dp[MAX_N][MAX_N][2];

void Floyd() {
  for (int k = 1; k <= v; ++k)
    for (int i = 1; i <= v; ++i)
      for (int j = 1; j <= v; ++j) {
        mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);
      }
}

void init_dp() {
  for (int i = 1; i <= n; ++i)
    for (int j = 0; j <= m; ++j)
      dp[i][j][0] = dp[i][j][1] = 1e15;
  dp[1][0][0] = dp[1][1][1] = 0.0;
}

void DP() {
  for (int i = 2; i <= n; ++i) {
    dp[i][0][0] = dp[i - 1][0][0] + mp[c[i - 1]][c[i]];
    for (int j = 1; j <= min(i, m); ++j) {
      dp[i][j][0] = min(dp[i - 1][j][0] + mp[c[i - 1]][c[i]], dp[i - 1][j][1] + k[i - 1] * mp[d[i - 1]][c[i]] + (1 - k[i - 1]) * mp[c[i - 1]][c[i]]);
      dp[i][j][1] = min(dp[i - 1][j - 1][0] + k[i] * mp[c[i - 1]][d[i]] + (1 - k[i]) * mp[c[i - 1]][c[i]], dp[i - 1][j - 1][1] + k[i - 1] * k[i] * mp[d[i - 1]][d[i]] + (1 - k[i - 1]) * k[i] * mp[c[i - 1]][d[i]] + k[i - 1] * (1 - k[i]) * mp[d[i - 1]][c[i]] + (1 - k[i - 1]) * (1 - k[i]) * mp[c[i - 1]][c[i]]);
    }
  }
}

int main() {
  read(n), read(m), read(v), read(e);
  for (int i = 1; i <= v; ++i)
    for (int j = 1; j <= v; ++j)
      mp[i][j] = (i == j) ? 0 : 1e15;
  for (int i = 1; i <= n; ++i)
    read(c[i]);
  for (int i = 1; i <= n; ++i)
    read(d[i]);
  for (int i = 1; i <= n; ++i)
    scanf("%lf", &k[i]);
  for (int i = 1, a, b, c; i <= e; ++i) {
    read(a), read(b), read(c);
    if (c < mp[a][b])
      mp[a][b] = mp[b][a] = c;
  }
  Floyd();
  init_dp();
  DP();
  double ans = 1e30;
  for (int i = 0; i <= m; ++i) {
    ans = min(ans, min(dp[n][i][0], dp[n][i][1]));
  }
  printf("%.2f", ans);
  return 0;
}
```
